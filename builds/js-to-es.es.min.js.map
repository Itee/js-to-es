{"version":3,"file":"js-to-es.es.min.js","sources":["../sources/utils.js","../sources/js-to-es.js"],"sourcesContent":["/**\r\n * @author [Tristan Valcke]{@link https://github.com/Itee}\r\n * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}\r\n *\r\n * @file Todo\r\n *\r\n * @example Todo\r\n *\r\n */\r\n\r\nimport {\r\n    existsSync,\r\n    readFileSync,\r\n    mkdirSync\r\n} from 'fs'\r\nimport {\r\n    sep,\r\n    join\r\n} from 'path'\r\n\r\n////////////////////////// CONDITIONAL UTILS /////////////////////////////\r\n\r\n/**\r\n * Check if the parameter is of type string\r\n *\r\n * @param {any} value - The value to check the string type\r\n * @return {boolean}\r\n */\r\nexport function isString ( value ) {\r\n\r\n    return ( typeof value === 'string' )\r\n\r\n}\r\n\r\n/**\r\n * Check if the parameter is NOT of type string\r\n *\r\n * @param {any} value - The value to check the non string type\r\n * @return {boolean}\r\n */\r\nexport function isNotString ( value ) {\r\n\r\n    return ( !isString( value ) )\r\n\r\n}\r\n\r\n/**\r\n * Check if the parameter is an array of string.\r\n * Note: An array of empty string will return true.\r\n *\r\n * @param {any} values - The value to check if it is an array of string\r\n * @return {boolean} - True if array of string, false otherwise\r\n */\r\nexport function isArrayOfString ( values ) {\r\n\r\n    if ( !Array.isArray( values ) ) { return false }\r\n\r\n    for ( let index = 0, numberOfValues = values.length ; index < numberOfValues ; index++ ) {\r\n\r\n        if ( isNotString( values[ index ] ) ) { return false }\r\n\r\n    }\r\n\r\n    return true\r\n\r\n}\r\n\r\n///////////////////////// FILES UTILS //////////////////////////////\r\n\r\nexport function fileExistForPath ( value ) {\r\n\r\n    return existsSync( value )\r\n\r\n}\r\n\r\nexport function fileNotExistForPath ( value ) {\r\n\r\n    return !fileExistForPath( value )\r\n\r\n}\r\n\r\nexport function getFileForPath ( value ) {\r\n\r\n    // In case files doesn't exist\r\n    if ( fileNotExistForPath( value ) ) {\r\n        throw new Error( `Invalid file path \"${value}\" file does not exist !` )\r\n    }\r\n\r\n    return readFileSync( value, 'utf8' )\r\n\r\n}\r\n\r\nexport function getUncommentedFileForPath ( value ) {\r\n\r\n    return getFileForPath( value ).replace( /\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/g, '$1' )\r\n\r\n}\r\n\r\nexport function createFoldersTree ( value ) {\r\n\r\n    value.split( sep )\r\n         .reduce( ( parentDir, childDir ) => {\r\n\r\n             const curDir = join( parentDir, childDir )\r\n\r\n             if ( fileNotExistForPath( curDir ) ) {\r\n                 mkdirSync( curDir )\r\n             }\r\n\r\n             return curDir\r\n\r\n         } )\r\n\r\n}\r\n\r\n///////////////////////// COMMON UTILS //////////////////////////////\r\n\r\nexport function makeUnique ( value, index, array ) {\r\n\r\n    return array.indexOf( value ) === index\r\n\r\n}\r\n","/**\r\n * @file The threejs convertor\r\n *\r\n * @author Itee <valcketristan@gmail.com>\r\n * @license MIT\r\n */\r\n\r\nimport {\r\n    readdirSync,\r\n    statSync,\r\n    writeFileSync\r\n} from 'fs'\r\nimport {\r\n    sep,\r\n    extname,\r\n    basename,\r\n    dirname,\r\n    relative,\r\n    resolve,\r\n    join\r\n} from 'path'\r\nimport {\r\n    isString,\r\n    isNotString,\r\n    isArrayOfString,\r\n    fileNotExistForPath,\r\n    getUncommentedFileForPath,\r\n    createFoldersTree,\r\n    makeUnique\r\n} from './utils'\r\n\r\n/**\r\n * Extend the String prototype if contains not exist.\r\n * It allow to check if the string contains or not a target string\r\n *\r\n * @type {Function}\r\n * @param {string} target - The string to match in current string\r\n * @return {boolean}\r\n */\r\nString.prototype.contains = String.prototype.contains || function ( target ) { return this.indexOf( target ) > -1 }\r\n\r\nclass JsToEs {\r\n\r\n    static JavascriptType = Object.freeze( {\r\n        AMD:       'AMD',\r\n        CJS:       'CJS',\r\n        Classic:   'Classic',\r\n        Es6:       'Es6',\r\n        Library:   'Library',\r\n        Prototype: 'Prototype',\r\n        UMD:       'UMD',\r\n        Unknown:   'Unknown'\r\n    } )\r\n\r\n    constructor ( options = {} ) {\r\n\r\n        // Public\r\n        this.inputs    = options.inputs || [ '' ]\r\n        this.excludes  = options.excludes || [ '' ]\r\n        this.output    = options.output || ''\r\n        this.edgeCases = options.edgeCases || []\r\n        this.banner    = options.banner || ''\r\n        this.namespace    = options.namespace || ''\r\n\r\n        // Private\r\n        this._exportMap = {}\r\n        this._fileMap   = {}\r\n        this._regex     = {\r\n            'AMD':       new RegExp( /define\\.amd/g ),\r\n            'CJS':       new RegExp( /module\\.exports\\s*=\\s*\\{?[^}]*}?/g ),\r\n            'UMD':       new RegExp( /\\(function\\s*\\(root,\\s*factory\\)\\s*\\{/g ),\r\n            'Classic':   new RegExp( `(${this._namespace}.(\\\\w+)\\\\s*=\\\\s*)+\\\\s*function`, 'g' ),\r\n            'Prototype': new RegExp( `prototype\\\\.constructor\\\\s?=\\\\s?(${this._namespace}\\\\.)?(\\\\w)+`, 'g' ),\r\n            'Library':   new RegExp( `${this._namespace}.(\\\\w+) = \\\\{` ),\r\n            'Es6':       new RegExp( /(export\\s(default|var))|((import|export)[\\r\\n\\s]*(default)?({[\\w\\s,]+}\\s?(from)?))/, 'g' )\r\n        }\r\n\r\n    }\r\n\r\n    get inputs () {\r\n        return this._inputs\r\n    }\r\n\r\n    set inputs ( value ) {\r\n\r\n        if ( isArrayOfString( value ) ) {\r\n\r\n            this._inputs = value\r\n\r\n        } else if ( isString( value ) ) {\r\n\r\n            this._inputs = [ value ]\r\n\r\n        } else {\r\n\r\n            throw new TypeError( 'Invalid inputs arguments, expected a String or Array of String' )\r\n\r\n        }\r\n\r\n    }\r\n\r\n    get excludes () {\r\n        return this._excludes\r\n    }\r\n\r\n    set excludes ( value ) {\r\n\r\n        if ( isArrayOfString( value ) ) {\r\n\r\n            this._excludes = value\r\n\r\n        } else if ( isString( value ) ) {\r\n\r\n            this._excludes = [ value ]\r\n\r\n        } else {\r\n\r\n            throw new TypeError( 'Invalid excludes arguments, expected a String or Array of String' )\r\n\r\n        }\r\n\r\n        return this\r\n\r\n    }\r\n\r\n    get output () {\r\n        return this._output\r\n    }\r\n\r\n    set output ( value ) {\r\n\r\n        if ( isString( value ) ) {\r\n\r\n            this._output = value\r\n\r\n        } else {\r\n\r\n            throw new TypeError( 'Invalid output arguments, expected a String' )\r\n\r\n        }\r\n\r\n        return this\r\n\r\n    }\r\n\r\n    get edgeCases () {\r\n        return this._edgeCases\r\n    }\r\n\r\n    set edgeCases ( value ) {\r\n\r\n        // Todo: object edge case or validate object structure of input value here !\r\n        this._edgeCases = value\r\n\r\n    }\r\n\r\n    get banner () {\r\n        return this._banner\r\n    }\r\n\r\n    set banner ( value ) {\r\n\r\n        if ( isNotString( value ) ) { throw new TypeError( 'Invalid banner argument, expect a string.' )}\r\n\r\n        this._banner = value\r\n    }\r\n\r\n    get namespace () {\r\n        return this._namespace\r\n    }\r\n\r\n    set namespace ( value ) {\r\n\r\n        if ( isNotString( value ) ) { throw new TypeError( 'Invalid namespace argument, expect a string.' )}\r\n\r\n        // namespace will be used in regex so escape it\r\n        // https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\r\n        this._namespace = value.replace( /[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&' )\r\n        this._regex  = {\r\n            'AMD':       new RegExp( /define\\.amd/g ),\r\n            'CJS':       new RegExp( /module\\.exports\\s*=\\s*\\{?[^}]*}?/g ),\r\n            'UMD':       new RegExp( /\\(function\\s*\\(root,\\s*factory\\)\\s*\\{/g ),\r\n            'Classic':   new RegExp( `(${this._namespace}.(\\\\w+)\\\\s*=\\\\s*)+\\\\s*function`, 'g' ),\r\n            'Prototype': new RegExp( `prototype\\\\.constructor\\\\s?=\\\\s?(${this._namespace}\\\\.)?(\\\\w)+`, 'g' ),\r\n            'Library':   new RegExp( `${this._namespace}.(\\\\w+) = \\\\{` ),\r\n            'Es6':       new RegExp( /(export\\s(default|var))|((import|export)[\\r\\n\\s]*(default)?({[\\w\\s,]+}\\s?(from)?))/, 'g' )\r\n        }\r\n\r\n    }\r\n\r\n    get exportMap () {\r\n        return this._exportMap\r\n    }\r\n\r\n    get fileMap () {\r\n        return this._fileMap\r\n    }\r\n\r\n    /**\r\n     * Return all the files paths under filePaths in a recursive way.\r\n     *\r\n     * @param filePaths - An array of string, representing the base path where looking for get all files paths\r\n     * @return {Array.<string>} - An array of files paths\r\n     * @private\r\n     */\r\n    static _getFilesPathsUnder ( filePaths ) {\r\n\r\n        let files = []\r\n\r\n        if ( Array.isArray( filePaths ) ) {\r\n\r\n            let filePath = undefined\r\n            for ( let pathIndex = 0, numberOfPaths = filePaths.length ; pathIndex < numberOfPaths ; pathIndex++ ) {\r\n\r\n                filePath      = filePaths[ pathIndex ]\r\n                const results = JsToEs._checkStateOf( filePath )\r\n                Array.prototype.push.apply( files, results )\r\n\r\n            }\r\n\r\n        } else {\r\n\r\n            const results = JsToEs._checkStateOf( filePaths )\r\n            Array.prototype.push.apply( files, results )\r\n\r\n        }\r\n\r\n        return files\r\n\r\n    }\r\n\r\n    static _getFilesPathsUnderFolder ( folder ) {\r\n\r\n        const files = []\r\n\r\n        readdirSync( folder ).forEach( ( name ) => {\r\n\r\n            const filePath = resolve( folder, name )\r\n            const results  = JsToEs._checkStateOf( filePath )\r\n            Array.prototype.push.apply( files, results )\r\n\r\n        } )\r\n\r\n        return files\r\n\r\n    }\r\n\r\n    static _checkStateOf ( filePath ) {\r\n\r\n        if ( fileNotExistForPath( filePath ) ) {\r\n            throw new ReferenceError( `Invalid file path \"${filePath}\".` )\r\n        }\r\n\r\n        const stats = statSync( filePath )\r\n        if ( stats.isFile() ) {\r\n\r\n            return [ filePath ]\r\n\r\n        } else if ( stats.isDirectory() ) {\r\n\r\n            return JsToEs._getFilesPathsUnderFolder( filePath )\r\n\r\n        } else {\r\n\r\n            throw new ReferenceError( `Invalid stats file object.` )\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Will filter file paths an keep only js files\r\n     *\r\n     * @param {Array.<string>} filePaths - An array of path to filter\r\n     * @return {Array.<string>} The filtered path with only javascript files\r\n     * @private\r\n     */\r\n    static _filterJavascriptFiles ( filePaths ) {\r\n\r\n        let filteredFilesPath = []\r\n\r\n        let filePath = undefined\r\n        for ( let filePathIndex = 0, numberOfFilePaths = filePaths.length ; filePathIndex < numberOfFilePaths ; filePathIndex++ ) {\r\n\r\n            filePath = filePaths[ filePathIndex ]\r\n\r\n            // Not a js file like fonts or shaders\r\n            const fileExtension = extname( filePath )\r\n            if ( fileExtension !== '.js' ) {\r\n                //            console.log( 'Not Js:  ' + filePath )\r\n                continue\r\n            }\r\n\r\n            filteredFilesPath.push( filePath )\r\n\r\n        }\r\n\r\n        return filteredFilesPath\r\n\r\n    }\r\n\r\n    /**\r\n     * Will create an array without the strings in filePaths that are matched in excludes paths\r\n     *\r\n     * @param {Array.<string>} filePaths - An array of string to clean\r\n     * @param {Array.<string>} excludes - The paths to remove\r\n     * @return {Array.<string>} The cleaned filePaths of excludes paths\r\n     * @private\r\n     */\r\n    static _excludesFilesPaths ( filePaths, excludes ) {\r\n\r\n        let filteredFilesPath = []\r\n\r\n        let filePath = undefined\r\n        for ( let filePathIndex = 0, numberOfFilePaths = filePaths.length ; filePathIndex < numberOfFilePaths ; filePathIndex++ ) {\r\n            filePath = filePaths[ filePathIndex ]\r\n\r\n            if ( JsToEs._isExclude( filePath, excludes ) ) {\r\n                //            console.log( 'Exclude: ' + filePath )\r\n                continue\r\n            }\r\n\r\n            filteredFilesPath.push( filePath )\r\n\r\n        }\r\n\r\n        return filteredFilesPath\r\n\r\n    }\r\n\r\n    static _isExclude ( path, excludes ) {\r\n\r\n        let isExclude      = false\r\n        let excludePattern = undefined\r\n        for ( let i = 0, pathLength = excludes.length ; i < pathLength ; i++ ) {\r\n\r\n            excludePattern = excludes[ i ]\r\n\r\n            if ( excludePattern.length === 0 ) {\r\n                continue\r\n            }\r\n\r\n            // In case this is a file name it must fully match\r\n            if ( excludePattern.indexOf( '.' ) > -1 ) {\r\n\r\n                const fileName = path.replace( /^.*(\\\\|\\/|\\:)/, '' )\r\n                if ( fileName === excludePattern ) {\r\n                    isExclude = true\r\n                }\r\n\r\n            } else if ( path.contains( excludePattern ) ) {\r\n                isExclude = true\r\n            }\r\n\r\n        }\r\n\r\n        return isExclude\r\n\r\n    }\r\n\r\n    static _getFileType ( file, regex ) {\r\n\r\n        const es6Match = file.match( regex[ JsToEs.JavascriptType.Es6 ] )\r\n        if ( es6Match && es6Match.length > 0 ) {\r\n            return JsToEs.JavascriptType.Es6\r\n        }\r\n\r\n        const amdMatch = file.match( regex[ JsToEs.JavascriptType.AMD ] )\r\n        if ( amdMatch && amdMatch.length > 0 ) {\r\n            return JsToEs.JavascriptType.AMD\r\n        }\r\n\r\n        const cjsMatch = file.match( regex[ JsToEs.JavascriptType.CJS ] )\r\n        if ( cjsMatch && cjsMatch.length > 0 ) {\r\n            return JsToEs.JavascriptType.CJS\r\n        }\r\n\r\n        const classicObjectMatch = file.match( regex[ JsToEs.JavascriptType.Classic ] )\r\n        if ( classicObjectMatch && classicObjectMatch.length > 0 ) {\r\n            return JsToEs.JavascriptType.Classic\r\n        }\r\n\r\n        const prototypedObjectMatch = file.match( regex[ JsToEs.JavascriptType.Prototype ] )\r\n        if ( prototypedObjectMatch && prototypedObjectMatch.length > 0 ) {\r\n            return JsToEs.JavascriptType.Prototype\r\n        }\r\n\r\n        const libMatch = file.match( regex[ JsToEs.JavascriptType.Library ] )\r\n        if ( libMatch && libMatch.length > 0 ) {\r\n            return JsToEs.JavascriptType.Library\r\n        }\r\n\r\n        return JsToEs.JavascriptType.Unknown\r\n\r\n    }\r\n\r\n    static _convertFile ( banner, fileDatas, exportMap ) {\r\n\r\n        const outputPath = fileDatas.output\r\n        const outputDir  = dirname( outputPath )\r\n\r\n        const formatedImports = JsToEs._formatImportStatements( outputPath, exportMap, fileDatas.imports )\r\n        const formatedFile    = JsToEs._formatReplacementStatements( fileDatas.file, fileDatas.replacements )\r\n        const formatedExports = JsToEs._formatExportStatements( outputPath, fileDatas.exports )\r\n        const outputFile      = banner + formatedImports + formatedFile + formatedExports\r\n\r\n        createFoldersTree( outputDir )\r\n        writeFileSync( outputPath, outputFile )\r\n\r\n    }\r\n\r\n    static _copyFile ( banner, fileDatas ) {\r\n\r\n        const outputPath = fileDatas.output\r\n        const outputDir  = dirname( outputPath )\r\n        const file       = banner + fileDatas.file\r\n\r\n        createFoldersTree( outputDir )\r\n        writeFileSync( outputPath, file )\r\n\r\n    }\r\n\r\n    static _getAllImportsStatementIn ( namespace, file, exports ) {\r\n\r\n        let statements = []\r\n\r\n        const matchs = file.match( /import\\s+(?:(?:({[\\w\\s,]+})|([\\w,*-]+))\\s+)+from/g ) || []\r\n        matchs.filter( makeUnique )\r\n              .forEach( ( value ) => {\r\n\r\n                  const results = value.replace( 'import', '' )\r\n                                       .replace( 'from', '' )\r\n                                       .replace( /[{}]/g, '' )\r\n                                       .replace( /\\s+/g, '' )\r\n                                       .split( ',' )\r\n\r\n                  // Check if the extends statement is not about the exported object !\r\n                  let result = undefined\r\n                  for ( let i = results.length - 1 ; i >= 0 ; --i ) {\r\n                      result = results[ i ]\r\n\r\n                      // Check if import matching does no concerne inner class\r\n                      if ( exports.includes( result ) ) {\r\n                          return\r\n                      }\r\n\r\n                      if ( !result ) {\r\n                          results.splice( i, 1 )\r\n                      }\r\n\r\n                  }\r\n\r\n                  if ( results.length > 0 ) {\r\n                      Array.prototype.push.apply( statements, results )\r\n                  }\r\n\r\n              } )\r\n\r\n        return statements\r\n\r\n    }\r\n\r\n    static _getAllExtendsStatementIn ( namespace, file, exports ) {\r\n\r\n        let statements = []\r\n\r\n        // By Object.assign\r\n        const fileRegex   = new RegExp( `Object\\\\.assign\\\\(\\\\s*((${namespace}.)?(\\\\w+)\\\\.prototype[,]*\\\\s*){2,}`, 'g' )\r\n        const namespaceRegex = new RegExp( `${namespace}\\\\.`, 'g' )\r\n\r\n        const matchs = file.match( fileRegex ) || []\r\n        matchs.filter( makeUnique )\r\n              .forEach( ( value ) => {\r\n\r\n                  const results = value.replace( /Object\\.assign\\(\\s+/g, '' )\r\n                                       .replace( namespaceRegex, '' )\r\n                                       .replace( /\\.prototype/g, '' )\r\n                                       .replace( /\\s+/g, '' )\r\n                                       .split( ',' )\r\n\r\n                  // Check if the extends statement is not about the exported object !\r\n                  let result = undefined\r\n                  for ( let i = results.length - 1 ; i >= 0 ; --i ) {\r\n                      result = results[ i ]\r\n\r\n                      // Check if import matching does no concerne inner class\r\n                      if ( !result || exports.includes( result ) ) {\r\n                          results.splice( i, 1 )\r\n                      }\r\n\r\n                  }\r\n\r\n                  if ( results.length > 0 ) {\r\n                      Array.prototype.push.apply( statements, results )\r\n                  }\r\n\r\n              } )\r\n\r\n        return statements\r\n\r\n    }\r\n\r\n    static _getAllInheritStatementsIn ( namespace, file, exports ) {\r\n\r\n        let statements = []\r\n\r\n        const fileRegex   = new RegExp( `Object\\\\.create\\\\(\\\\s+((${namespace}.)?(\\\\w+)\\\\.prototype[,]?\\\\s*)+\\\\)`, 'g' )\r\n        const namespaceRegex = new RegExp( `Object\\\\.create\\\\(\\\\s+(${namespace}.)?`, 'g' )\r\n\r\n        const matchs = file.match( fileRegex ) || []\r\n        matchs.filter( makeUnique )\r\n              .forEach( ( value ) => {\r\n\r\n                  const results = value.replace( namespaceRegex, '' )\r\n                                       .replace( /\\.prototype/g, '' )\r\n                                       .replace( /\\)/g, '' )\r\n                                       .replace( /\\s+/g, '' )\r\n                                       .split( ',' )\r\n\r\n                  // Check if the inherit statement is not about the exported object !\r\n                  let result = undefined\r\n                  for ( let i = 0, resultLength = results.length ; i < resultLength ; i++ ) {\r\n                      result = results[ i ]\r\n\r\n                      if ( !result || exports.includes( result ) ) {\r\n                          results.splice( i, 1 )\r\n                      }\r\n\r\n                  }\r\n\r\n                  if ( results.length > 0 ) {\r\n                      Array.prototype.push.apply( statements, results )\r\n                  }\r\n\r\n              } )\r\n\r\n        return statements\r\n\r\n    }\r\n\r\n    static _getAllNewStatementIn ( namespace, file, exports ) {\r\n\r\n        let statements = []\r\n\r\n        const fileRegex   = new RegExp( `new\\\\s${namespace}.(\\\\w+)\\\\s?`, 'g' )\r\n        const namespaceRegex = new RegExp( `new\\\\s${namespace}\\\\.`, 'g' )\r\n\r\n        const matchs = file.match( fileRegex ) || []\r\n        matchs.filter( makeUnique )\r\n              .forEach( ( value ) => {\r\n\r\n                  const result = value.replace( namespaceRegex, '' )\r\n                                      .replace( /\\s+/g, '' )\r\n\r\n                  // Check if the new statement is not about the exported object !\r\n                  if ( exports.includes( result ) ) {\r\n                      return\r\n                  }\r\n\r\n                  if ( result ) { statements.push( result ) }\r\n\r\n              } )\r\n\r\n        return statements\r\n\r\n    }\r\n\r\n    static _getAllInstanceOfStatementIn ( namespace, file, exports ) {\r\n\r\n        let statements = []\r\n\r\n        const fileRegex   = new RegExp( `instanceof\\\\s${namespace}.(\\\\w+)\\\\s?`, 'g' )\r\n        const namespaceRegex = new RegExp( `instanceof\\\\s${namespace}\\\\.`, 'g' )\r\n\r\n        const matchs = file.match( fileRegex ) || []\r\n        matchs.filter( makeUnique )\r\n              .forEach( ( value ) => {\r\n\r\n                  const result = value.replace( namespaceRegex, '' )\r\n                                      .replace( /\\s+/g, '' )\r\n\r\n                  // Check if the new statement is not about the exported object !\r\n                  if ( exports.includes( result ) ) {\r\n                      return\r\n                  }\r\n\r\n                  if ( result ) { statements.push( result ) }\r\n\r\n              } )\r\n\r\n        return statements\r\n\r\n    }\r\n\r\n    static _getImportsFor ( namespace, file, exports, edgeCase ) {\r\n\r\n        if ( edgeCase.importsOverride ) {\r\n            return edgeCase.importsOverride\r\n        }\r\n\r\n        let imports = []\r\n\r\n        Array.prototype.push.apply( imports, JsToEs._getAllImportsStatementIn( namespace, file, exports ) )\r\n        Array.prototype.push.apply( imports, JsToEs._getAllInheritStatementsIn( namespace, file, exports ) )\r\n        Array.prototype.push.apply( imports, JsToEs._getAllExtendsStatementIn( namespace, file, exports ) )\r\n        Array.prototype.push.apply( imports, JsToEs._getAllNewStatementIn( namespace, file, exports ) )\r\n        Array.prototype.push.apply( imports, JsToEs._getAllInstanceOfStatementIn( namespace, file, exports ) )\r\n\r\n        if ( edgeCase.imports ) {\r\n            Array.prototype.push.apply( imports, edgeCase.imports )\r\n        }\r\n\r\n        // A class can be inherited and dynamicaly create by new in the same file so we need to check uniqueness\r\n        return imports.filter( makeUnique )\r\n\r\n    }\r\n\r\n    static _formatImportStatements ( importerFilePath, exportMap, objectNames ) {\r\n\r\n        let importStatements = []\r\n        let importsMap       = {}\r\n\r\n        objectNames.forEach( ( objectName ) => {\r\n\r\n            if ( Array.isArray( objectName ) ) {\r\n\r\n                importsMap[ objectName[ 2 ] ] = []\r\n                importsMap[ objectName[ 2 ] ].push( objectName[ 0 ] )\r\n\r\n            } else {\r\n\r\n                const exporterFilePath = exportMap[ objectName ]\r\n                if ( !exporterFilePath ) {\r\n                    console.error( `WARNING: Missing export statement for: ${objectName} in ${importerFilePath} this is an edge case that will probably need to be managed manually !!!` )\r\n                    return\r\n                }\r\n\r\n                // Compute relative path from importer to exporter\r\n                const importerDirectoryName      = dirname( importerFilePath )\r\n                const exporterDirectoryName      = dirname( exporterFilePath )\r\n                const exporterBaseName           = basename( exporterFilePath )\r\n                const relativePath               = relative( importerDirectoryName, exporterDirectoryName )\r\n                const firstChar                  = relativePath[ 0 ]\r\n                const notStartWithDot            = (firstChar !== '.')\r\n                const relativeFilePath           = (notStartWithDot) ? './' + join( relativePath, exporterBaseName ) : join( relativePath, exporterBaseName )\r\n                const relativeFilePathNormalized = relativeFilePath.replace( /\\\\/g, '/' )\r\n\r\n                if ( !importsMap[ relativeFilePathNormalized ] ) {\r\n                    importsMap[ relativeFilePathNormalized ] = []\r\n                }\r\n                importsMap[ relativeFilePathNormalized ].push( objectName )\r\n\r\n            }\r\n\r\n        } )\r\n\r\n        for ( let importPath in importsMap ) {\r\n\r\n            let imports = importsMap[ importPath ]\r\n\r\n            let formatedImports = 'import {'\r\n\r\n            if ( imports.length === 1 ) {\r\n\r\n                formatedImports += ` ${imports[ 0 ]} `\r\n\r\n            } else if ( imports.length > 1 ) {\r\n\r\n                formatedImports += '\\n'\r\n\r\n                let importedObject = undefined\r\n                for ( let i = 0, numberOfImports = imports.length ; i < numberOfImports ; i++ ) {\r\n                    importedObject = imports[ i ]\r\n\r\n                    if ( i === numberOfImports - 1 ) {\r\n                        formatedImports += `\\t${importedObject}\\n`\r\n                    } else {\r\n                        formatedImports += `\\t${importedObject},\\n`\r\n                    }\r\n\r\n                }\r\n\r\n            } else {\r\n\r\n                console.error( `WARNING: ${basename( importPath )} does not contains imports, fallback to file name export...` )\r\n\r\n            }\r\n            formatedImports += `} from '${importPath}'`\r\n\r\n            importStatements.push( formatedImports )\r\n\r\n        }\r\n\r\n        return importStatements.join( '\\n' ).concat( '\\n\\n' ) // don't forget last feed line\r\n\r\n    }\r\n\r\n    static _getEs6ReplacementsFor ( namespace ) {\r\n\r\n        let replacements = []\r\n\r\n        replacements.push( [ /import\\s+(?:(?:({[\\w\\s,]+})|([\\w,*-]+))\\s+)+from.+/g, '' ] )\r\n        replacements.push( [ /export var/g, 'var' ] )\r\n        replacements.push( [ /export function/g, 'function' ] )\r\n        replacements.push( [ /export(?:[^s]|)(\\s*{(?:[\\w\\s,])+}\\s*)(?:(?:from)?\\s?['\"][./]+[\\w.]+['\"])?;?/g, '' ] )\r\n\r\n        return replacements\r\n\r\n    }\r\n\r\n    static _getExportsReplacementsFor ( namespace, exports ) {\r\n\r\n        let replacements = []\r\n\r\n        for ( let i = 0, numberOfExports = exports.length ; i < numberOfExports ; i++ ) {\r\n\r\n            const exportedObject = exports[ i ]\r\n\r\n            const regex2       = new RegExp( `${namespace}.${exportedObject} =`, 'g' )\r\n            const replacement2 = `var ${exportedObject} =`\r\n            replacements.push( [ regex2, replacement2 ] )\r\n\r\n            const regex1       = new RegExp( ' = var ', 'g' )\r\n            const replacement1 = ' = '\r\n            replacements.push( [ regex1, replacement1 ] )\r\n\r\n        }\r\n\r\n        return replacements\r\n\r\n    }\r\n\r\n    static _getIifeReplacementsFor ( namespace, file ) {\r\n\r\n        const unspacedFile = file.replace( /\\s+/g, '' )\r\n        let replacements   = []\r\n\r\n        // Check if this iife is a main englobing function or inner function\r\n        const matchIife = unspacedFile.match( /^\\(\\s*function\\s*\\(\\s*(\\w+)?\\s*\\)\\s*\\{/g ) || []\r\n        if ( matchIife.length > 0 ) {\r\n\r\n            replacements.push( [ /\\(\\s*function\\s*\\(\\s*(\\w+)?\\s*\\)\\s*\\{/, '' ] )\r\n\r\n            // Check for end type with params or not\r\n            const matchParametrizedEndIife = unspacedFile.match( /}\\s*\\)\\s*\\(\\s*[\\w.=\\s]*(\\|\\|\\s*\\{\\})?\\s*\\);?$/ ) || []\r\n            const matchEmptyEndIife        = unspacedFile.match( /}\\s*\\(\\s*[\\w]*\\s*\\)\\s*\\);?$/ ) || []\r\n            if ( matchParametrizedEndIife.length > 0 ) {\r\n\r\n                replacements.push( [ /}\\s*\\)\\s*\\(\\s*[\\w.=\\s]*(\\|\\|\\s*\\{\\})?\\s*\\);?/, '' ] )\r\n\r\n            } else if ( matchEmptyEndIife.length > 0 ) {\r\n\r\n                replacements.push( [ /}\\s*\\(\\s*[\\w]*\\s*\\)\\s*\\);?/, '' ] )\r\n\r\n            } else {\r\n\r\n                throw new Error( 'Unable to match end of IIFE.' )\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return replacements\r\n\r\n    }\r\n\r\n    static _getNamespaceReplacementsFor ( namespace ) {\r\n\r\n        const regex1 = new RegExp( `${namespace}\\\\.Math\\\\.`, 'g' )\r\n        const regex2 = new RegExp( `${namespace}\\.`, 'g' )\r\n\r\n        return [\r\n            [ regex1, '_Math.' ],\r\n            [ regex2, '' ]\r\n        ]\r\n\r\n    }\r\n\r\n    static _getAutoAssignementReplacementsFor ( namespace ) {\r\n\r\n        return [ [ /var\\s?(\\w+)\\s?=\\s?\\1;/g, '' ] ]\r\n\r\n    }\r\n\r\n    static _getReplacementsFor ( namespace, file, exports, edgeCase ) {\r\n\r\n        if ( edgeCase.replacementsOverride ) {\r\n            return edgeCase.replacementsOverride\r\n        }\r\n\r\n        let replacements = []\r\n\r\n        Array.prototype.push.apply( replacements, JsToEs._getEs6ReplacementsFor( namespace ) )\r\n        Array.prototype.push.apply( replacements, JsToEs._getExportsReplacementsFor( namespace, exports ) )\r\n        Array.prototype.push.apply( replacements, JsToEs._getIifeReplacementsFor( namespace, file ) )\r\n        Array.prototype.push.apply( replacements, JsToEs._getNamespaceReplacementsFor( namespace ) )\r\n        Array.prototype.push.apply( replacements, JsToEs._getAutoAssignementReplacementsFor( namespace ) )\r\n\r\n        if ( edgeCase.replacements ) {\r\n            Array.prototype.push.apply( replacements, edgeCase.replacements )\r\n        }\r\n\r\n        return replacements\r\n\r\n    }\r\n\r\n    static _formatReplacementStatements ( file, replacements ) {\r\n\r\n        let _file = file\r\n        for ( let replaceIndex = 0, numberOfReplacements = replacements.length ; replaceIndex < numberOfReplacements ; replaceIndex++ ) {\r\n\r\n            const replacement = replacements[ replaceIndex ]\r\n            _file             = _file.replace( replacement[ 0 ], replacement[ 1 ] )\r\n\r\n        }\r\n        return _file\r\n\r\n    }\r\n\r\n    static _getExportsStatementsInES6File ( namespace, file ) {\r\n\r\n        let exportedElements = []\r\n\r\n        // Todo: May be it should be splitted by export type... direct, named, default, as etc...\r\n        const es6MatchedExports = file.match( /export(?:[^s]|)(?:(?:\\s*{([\\w\\s,]+)}\\s*)(?:(?:from)?\\s?['\"]([./]+[\\w.]+['\"]);?)?|(var\\s+.+))/g )\r\n        if ( es6MatchedExports ) {\r\n\r\n            // Clean\r\n            es6MatchedExports.forEach( ( value ) => {\r\n\r\n                if ( value.contains( 'from' ) ) {\r\n\r\n                    const splitOnFrom = value.split( 'from' )\r\n                    const exports     = splitOnFrom[ 0 ]\r\n                        .replace( /export/g, '' )\r\n                        .replace( /[\\s\\n\\r;{}]+/g, '' )\r\n                    //                    .split( ',' )\r\n\r\n                    const exportFile = splitOnFrom[ 1 ].replace( /[\\s'\";]+/g, '' )\r\n\r\n                    // Todo: allow exports like 'foo, bar, baz' and parse it when create exports statements\r\n                    Array.prototype.push.apply( exportedElements, [ [ exports, 'from', exportFile ] ] )\r\n                    return\r\n\r\n                }\r\n\r\n                if ( value.contains( 'as' ) ) {\r\n\r\n                    value = value.replace( /\\w+\\sas/g, '' )\r\n\r\n                }\r\n\r\n                if ( value.contains( 'var' ) ) {\r\n\r\n                    value = value.replace( /export/g, '' )\r\n                                 .replace( /var/g, '' )\r\n                                 .replace( /\\s*=\\s*.+/g, '' )\r\n\r\n                }\r\n\r\n                if ( value.contains( 'function' ) ) {\r\n\r\n                    value = value.replace( /function/g, '' )\r\n\r\n                }\r\n\r\n                const results = value.replace( /export/g, '' )\r\n                                     .replace( /[\\s\\n\\r;{}]+/g, '' )\r\n                                     .split( ',' )\r\n\r\n                Array.prototype.push.apply( exportedElements, results )\r\n\r\n            } )\r\n\r\n        }\r\n\r\n        return exportedElements\r\n\r\n    }\r\n\r\n    static _getExportsStatementsInAMDFile ( namespace, file ) {\r\n\r\n        console.error( `WARNING: File is unable to be process... It is an AMD module. Sorry for the disagreement.` )\r\n        return []\r\n\r\n    }\r\n\r\n    static _getExportsStatementsInCJSFile ( namespace, file ) {\r\n\r\n        let exportedElements = []\r\n\r\n        const fileRegex = new RegExp( /module\\.exports\\s*=\\s*\\{?[^}]*}?/g )\r\n\r\n        const commonjsExports = file.match( fileRegex )\r\n        if ( commonjsExports ) {\r\n\r\n            // Clean\r\n            commonjsExports.forEach( ( value ) => {\r\n\r\n                const results = value.replace( /module\\.exports/g, '' )\r\n                                     .replace( /[\\s\\n\\r;{}=]+/g, '' )\r\n                                     .split( ',' )\r\n\r\n                Array.prototype.push.apply( exportedElements, results )\r\n\r\n            } )\r\n\r\n        }\r\n\r\n        return exportedElements\r\n\r\n    }\r\n\r\n    static _getExportsStatementsInClassicFile ( namespace, file ) {\r\n\r\n        let exportedElements = []\r\n\r\n        const fileRegex   = new RegExp( `(${namespace}.(\\\\w+)\\\\s*=\\\\s*)+\\\\s*function`, 'g' )\r\n        const namespaceRegex = new RegExp( `${namespace}\\\\.|\\\\s*=\\\\s*function`, 'g' )\r\n\r\n        const potentialClassicObjectExports = file.match( fileRegex )\r\n        if ( potentialClassicObjectExports ) {\r\n\r\n            // Clean\r\n            potentialClassicObjectExports.forEach( ( value ) => {\r\n\r\n                const results = value.replace( namespaceRegex, '' )\r\n                                     .replace( /\\s*/g, '' )\r\n                                     .split( '=' )\r\n\r\n                Array.prototype.push.apply( exportedElements, results )\r\n\r\n            } )\r\n\r\n        }\r\n\r\n        return exportedElements\r\n\r\n    }\r\n\r\n    static _getExportsStatementsInPrototypedFile ( namespace, file ) {\r\n\r\n        let exportedElements = []\r\n\r\n        const fileRegex   = new RegExp( `prototype\\\\.constructor\\\\s?=\\\\s?(${namespace}\\\\.)?(\\\\w)+`, 'g' )\r\n        const namespaceRegex = new RegExp( `${namespace}\\\\.`, 'g' )\r\n\r\n        const potentialPrototypedObjectExports = file.match( fileRegex )\r\n        if ( potentialPrototypedObjectExports ) {\r\n\r\n            // Clean\r\n            potentialPrototypedObjectExports.forEach( ( value ) => {\r\n\r\n                const result = value.replace( /prototype\\.constructor\\s?=\\s?/g, '' )\r\n                                    .replace( namespaceRegex, '' )\r\n\r\n                exportedElements.push( result )\r\n\r\n            } )\r\n\r\n        }\r\n\r\n        return exportedElements\r\n\r\n    }\r\n\r\n    static _getExportsStatementInLibraryFile ( namespace, file ) {\r\n\r\n        let exportedElements = []\r\n\r\n        const fileRegex   = new RegExp( `${namespace}.(\\\\w+) = \\\\{`, 'g' )\r\n        const namespaceRegex = new RegExp( `${namespace}\\\\.| = \\\\{`, 'g' )\r\n\r\n        const potentialLibExports = file.match( fileRegex )\r\n        if ( potentialLibExports ) {\r\n\r\n            // Clean\r\n            potentialLibExports.forEach( ( value ) => {\r\n\r\n                const result = value.replace( namespaceRegex, '' )\r\n\r\n                exportedElements.push( result )\r\n\r\n            } )\r\n\r\n        }\r\n\r\n        return exportedElements\r\n\r\n    }\r\n\r\n    static _getExportsFor ( namespace, fileType, file, baseName, edgeCase ) {\r\n\r\n        if ( edgeCase.exportsOverride ) {\r\n            return edgeCase.exportsOverride\r\n        }\r\n\r\n        let exports = undefined\r\n\r\n        switch ( fileType ) {\r\n\r\n            case JsToEs.JavascriptType.AMD:\r\n                exports = JsToEs._getExportsStatementsInAMDFile( namespace, file )\r\n                break\r\n\r\n            case JsToEs.JavascriptType.CJS:\r\n                exports = JsToEs._getExportsStatementsInCJSFile( namespace, file )\r\n                break\r\n\r\n            case JsToEs.JavascriptType.Classic:\r\n                exports = JsToEs._getExportsStatementsInClassicFile( namespace, file )\r\n                break\r\n\r\n            case JsToEs.JavascriptType.Es6:\r\n                exports = JsToEs._getExportsStatementsInES6File( namespace, file )\r\n                break\r\n\r\n            case JsToEs.JavascriptType.Library:\r\n                exports = JsToEs._getExportsStatementInLibraryFile( namespace, file )\r\n                break\r\n\r\n            case JsToEs.JavascriptType.Prototype:\r\n                exports = JsToEs._getExportsStatementsInPrototypedFile( namespace, file )\r\n                break\r\n\r\n            case JsToEs.JavascriptType.UMD:\r\n            case JsToEs.JavascriptType.Unknown:\r\n                console.error( `WARNING: ${baseName} does not contains explicit or implicit export, fallback to file name as export...` )\r\n                exports = [ baseName ]\r\n                break\r\n\r\n            default:\r\n                throw new RangeError( `Invalid switch parameter: ${fileType}` )\r\n                break\r\n\r\n        }\r\n\r\n        if ( edgeCase.exports ) {\r\n            Array.prototype.push.apply( exports, edgeCase.exports )\r\n        }\r\n\r\n        return exports.filter( makeUnique )\r\n\r\n    }\r\n\r\n    static _formatExportStatements ( filePath, exports ) {\r\n\r\n        // Formating\r\n        let formatedExports = ''\r\n\r\n        // First check for specified exports\r\n        let specificExports = []\r\n        let regularExports  = []\r\n\r\n        exports.forEach( exports => {\r\n\r\n            ( Array.isArray( exports ) ) ? specificExports.push( exports ) : regularExports.push( exports )\r\n\r\n        } )\r\n\r\n        if ( specificExports.length === 0 && regularExports.length === 0 ) {\r\n\r\n            console.error( `WARNING: ${basename( filePath )} does not contains explicit or implicit export, fallback to file name export... It must be an Es6 file with it own exports !` )\r\n            return ''\r\n\r\n        }\r\n\r\n        // Process specific exports\r\n        for ( let i = 0, numbSpecExp = specificExports.length ; i < numbSpecExp ; i++ ) {\r\n\r\n            const exports          = specificExports[ i ]\r\n            const exportedClass    = exports[ 0 ]\r\n            const exportAction     = exports[ 1 ]\r\n            const exportComplement = exports[ 2 ]\r\n\r\n            if ( exportAction === 'from' ) {\r\n\r\n                formatedExports += `export { ${exports[ 0 ]} } from \"${exportComplement}\"\\n`\r\n\r\n            } else if ( exportAction === 'as' ) {\r\n\r\n                formatedExports += `export { ${exports[ 0 ]} as ${exportComplement} }\\n`\r\n\r\n            } else {\r\n\r\n                // Todo: export { Foo as Bar } from 'Baz'\r\n                throw new Error( 'Invalid specified export action !' )\r\n\r\n            }\r\n\r\n        }\r\n\r\n        // Process regular exports\r\n        const numberOfExports = regularExports.length\r\n        if ( numberOfExports === 1 ) {\r\n\r\n            formatedExports += `\\nexport { ${exports[ 0 ]} }\\n`\r\n\r\n        } else if ( numberOfExports > 1 ) {\r\n\r\n            formatedExports += '\\nexport {\\n'\r\n            for ( let i = 0 ; i < numberOfExports ; i++ ) {\r\n\r\n                formatedExports += ( i === numberOfExports - 1 ) ? '\\t' + regularExports[ i ] + '\\n' : '\\t' + regularExports[ i ] + ',\\n'\r\n\r\n            }\r\n            formatedExports += '}\\n'\r\n\r\n        }\r\n\r\n        return formatedExports\r\n\r\n    }\r\n\r\n    static _getOutputFor ( filePath, outputBasePath, edgeCase ) {\r\n\r\n        if ( edgeCase.outputOverride ) {\r\n            return join( outputBasePath, edgeCase.outputOverride )\r\n        }\r\n\r\n        const specificPath = JsToEs._getSpecificPath( outputBasePath, filePath )\r\n        const outputPath   = join( outputBasePath, specificPath )\r\n        return outputPath\r\n\r\n    }\r\n\r\n    static _getSpecificPath ( base, target ) {\r\n\r\n        const baseSplits   = base.split( sep )\r\n        const targetSplits = target.split( sep )\r\n\r\n        let index          = 0\r\n        while(baseSplits[index] === targetSplits[index]) {\r\n            index++\r\n        }\r\n        index++\r\n\r\n        const specificPath = targetSplits.slice(index).join(sep)\r\n\r\n        return specificPath\r\n\r\n    }\r\n\r\n    static _createFilesMap ( namespace, regex, filesPaths, edgeCases, outputBasePath ) {\r\n\r\n        const filesMap = {}\r\n\r\n        filesPaths.forEach( ( filePath ) => {\r\n\r\n            const fileExtension = extname( filePath )\r\n            const baseName      = basename( filePath, fileExtension )\r\n\r\n            if ( filesMap[ baseName ] ) {\r\n                console.error( `WARNING: The file ${baseName} already exist in the file map ! Is there a duplicated file ???` )\r\n                return\r\n            }\r\n\r\n            const file         = getUncommentedFileForPath( filePath )\r\n            const isJavascript = ( fileExtension === '.js' )\r\n            const edgeCase     = edgeCases[ baseName ] || {}\r\n\r\n            if ( isJavascript ) {\r\n\r\n                const fileType     = JsToEs._getFileType( file, regex )\r\n                const exports      = JsToEs._getExportsFor( namespace, fileType, file, baseName, edgeCase )\r\n                const imports      = JsToEs._getImportsFor( namespace, file, exports, edgeCase )\r\n                const replacements = JsToEs._getReplacementsFor( namespace, file, exports, edgeCase )\r\n                const output       = JsToEs._getOutputFor( filePath, outputBasePath, edgeCase )\r\n\r\n                filesMap[ baseName ] = {\r\n                    isJavascript,\r\n                    fileType,\r\n                    file,\r\n                    imports,\r\n                    replacements,\r\n                    exports,\r\n                    output\r\n                }\r\n\r\n            } else {\r\n\r\n                const output = JsToEs._getOutputFor( filePath, outputBasePath, edgeCase )\r\n\r\n                filesMap[ baseName ] = {\r\n                    isJavascript,\r\n                    file,\r\n                    output\r\n                }\r\n\r\n            }\r\n\r\n        } )\r\n\r\n        return filesMap\r\n\r\n    }\r\n\r\n    static _createExportMap ( filesPaths, namespace, regex, edgeCases, outputBasePath ) {\r\n\r\n        const exportsMap = {}\r\n\r\n        filesPaths.forEach( ( filePath ) => {\r\n\r\n            const fileExtension = extname( filePath )\r\n            const baseName      = basename( filePath, fileExtension )\r\n            const edgeCase      = edgeCases[ baseName ] || {}\r\n            const file          = getUncommentedFileForPath( filePath )\r\n            const fileType      = JsToEs._getFileType( file, regex )\r\n            const exports       = JsToEs._getExportsFor( namespace, fileType, file, baseName, edgeCase )\r\n            const outputPath    = JsToEs._getOutputFor( filePath, outputBasePath, edgeCase )\r\n\r\n            exports.forEach( ( exportedElement ) => {\r\n\r\n                // Check case where export is an array with 'from' or 'as'\r\n                if ( Array.isArray( exportedElement ) ) {\r\n                    exportedElement = exportedElement[ 0 ]\r\n                }\r\n\r\n                const exportPath = exportsMap[ exportedElement ]\r\n                if ( exportPath ) {\r\n\r\n                    const exportName = basename( exportPath )\r\n                    const fileName   = basename( filePath )\r\n\r\n                    console.error( `WARNING: Element \"${exportedElement}\" in ${fileName} is already exported by source ${exportName}! Unable to determine which source file is the right exporter !!!` )\r\n                    return\r\n\r\n                }\r\n\r\n                exportsMap[ exportedElement ] = outputPath\r\n\r\n            } )\r\n\r\n        } )\r\n\r\n        return exportsMap\r\n\r\n    }\r\n\r\n    static _processFiles ( fileMap, exportMap, banner ) {\r\n\r\n        for ( let fileName in fileMap ) {\r\n\r\n            if ( !fileMap.hasOwnProperty( fileName ) ) { continue }\r\n\r\n            const fileData = fileMap[ fileName ]\r\n\r\n            if ( fileData.isJavascript ) {\r\n\r\n                JsToEs._convertFile( banner, fileData, exportMap )\r\n\r\n            } else {\r\n\r\n                JsToEs._copyFile( banner, fileData )\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    // Chainable setters\r\n    setInputs ( value ) {\r\n        this.inputs = value\r\n        return this\r\n    }\r\n\r\n    setExcludes ( value ) {\r\n        this.excludes = value\r\n        return this\r\n    }\r\n\r\n    setOutput ( value ) {\r\n        this.output = value\r\n        return this\r\n    }\r\n\r\n    setEdgeCases ( value ) {\r\n        this.edgeCases = value\r\n        return this\r\n    }\r\n\r\n    setBanner ( value ) {\r\n        this.banner = value\r\n        return this\r\n    }\r\n\r\n    setNamespace ( value ) {\r\n        this.namespace = value\r\n        return this\r\n    }\r\n\r\n    convert ( callback ) {\r\n\r\n        const inputs    = this._inputs\r\n        const excludes  = this._excludes\r\n        const output    = this._output\r\n        const edgeCases = this._edgeCases\r\n        const banner    = this._banner\r\n        const namespace    = this._namespace\r\n        const regex     = this._regex\r\n\r\n        if ( callback ) {\r\n\r\n            try {\r\n\r\n                const allFilesPaths       = JsToEs._getFilesPathsUnder( inputs )\r\n                const availableFilesPaths = JsToEs._excludesFilesPaths( allFilesPaths, excludes )\r\n                const jsFiles             = JsToEs._filterJavascriptFiles( availableFilesPaths )\r\n\r\n                this._fileMap   = JsToEs._createFilesMap( namespace, regex, availableFilesPaths, edgeCases, output )\r\n                this._exportMap = JsToEs._createExportMap( jsFiles, namespace, regex, edgeCases, output )\r\n\r\n                JsToEs._processFiles( this._fileMap, this._exportMap, banner )\r\n\r\n                callback()\r\n\r\n            } catch ( error ) {\r\n\r\n                callback( error )\r\n\r\n            }\r\n\r\n        } else {\r\n\r\n            return new Promise( ( resolve, rejects ) => {\r\n\r\n                try {\r\n\r\n                    const allFilesPaths       = JsToEs._getFilesPathsUnder( inputs )\r\n                    const availableFilesPaths = JsToEs._excludesFilesPaths( allFilesPaths, excludes )\r\n                    const jsFiles             = JsToEs._filterJavascriptFiles( availableFilesPaths )\r\n\r\n                    this._fileMap   = JsToEs._createFilesMap( namespace, regex, availableFilesPaths, edgeCases, output )\r\n                    this._exportMap = JsToEs._createExportMap( jsFiles, namespace, regex, edgeCases, output )\r\n\r\n                    JsToEs._processFiles( this._fileMap, this._exportMap, banner )\r\n\r\n                    resolve()\r\n\r\n                } catch ( error ) {\r\n\r\n                    rejects( error )\r\n\r\n                }\r\n\r\n            } )\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nexport { JsToEs }\r\n"],"names":["isString","value","isNotString","isArrayOfString","values","Array","isArray","index","numberOfValues","length","fileExistForPath","existsSync","fileNotExistForPath","getFileForPath","Error","readFileSync","getUncommentedFileForPath","replace","createFoldersTree","split","sep","reduce","parentDir","childDir","curDir","join","mkdirSync","makeUnique","array","indexOf","String","prototype","contains","target","JsToEs","options","this","inputs","excludes","output","edgeCases","banner","namespace","_exportMap","_fileMap","_regex","AMD","RegExp","CJS","UMD","Classic","_namespace","Prototype","Library","Es6","callback","_inputs","_excludes","_output","_edgeCases","_banner","regex","Promise","resolve","rejects","allFilesPaths","_getFilesPathsUnder","availableFilesPaths","_excludesFilesPaths","jsFiles","_filterJavascriptFiles","_this","_createFilesMap","_createExportMap","_processFiles","error","TypeError","filePaths","files","filePath","undefined","pathIndex","numberOfPaths","results","_checkStateOf","push","apply","folder","readdirSync","forEach","name","ReferenceError","stats","statSync","isFile","isDirectory","_getFilesPathsUnderFolder","filteredFilesPath","filePathIndex","numberOfFilePaths","extname","_isExclude","path","isExclude","excludePattern","i","pathLength","file","es6Match","match","JavascriptType","amdMatch","cjsMatch","classicObjectMatch","prototypedObjectMatch","libMatch","Unknown","fileDatas","exportMap","outputPath","outputDir","dirname","outputFile","_formatImportStatements","imports","_formatReplacementStatements","replacements","_formatExportStatements","exports","writeFileSync","statements","filter","result","includes","splice","fileRegex","namespaceRegex","resultLength","edgeCase","importsOverride","_getAllImportsStatementIn","_getAllInheritStatementsIn","_getAllExtendsStatementIn","_getAllNewStatementIn","_getAllInstanceOfStatementIn","importerFilePath","objectNames","importStatements","importsMap","objectName","exporterFilePath","console","importerDirectoryName","exporterDirectoryName","exporterBaseName","basename","relativePath","relative","relativeFilePathNormalized","importPath","formatedImports","importedObject","numberOfImports","concat","numberOfExports","exportedObject","regex2","replacement2","regex1","unspacedFile","matchParametrizedEndIife","matchEmptyEndIife","replacementsOverride","_getEs6ReplacementsFor","_getExportsReplacementsFor","_getIifeReplacementsFor","_getNamespaceReplacementsFor","_getAutoAssignementReplacementsFor","_file","replaceIndex","numberOfReplacements","replacement","exportedElements","es6MatchedExports","splitOnFrom","exportFile","commonjsExports","potentialClassicObjectExports","potentialPrototypedObjectExports","potentialLibExports","fileType","baseName","exportsOverride","_getExportsStatementsInAMDFile","_getExportsStatementsInCJSFile","_getExportsStatementsInClassicFile","_getExportsStatementsInES6File","_getExportsStatementInLibraryFile","_getExportsStatementsInPrototypedFile","RangeError","formatedExports","specificExports","regularExports","numbSpecExp","exportAction","exportComplement","outputBasePath","outputOverride","specificPath","_getSpecificPath","base","baseSplits","targetSplits","slice","filesPaths","filesMap","fileExtension","isJavascript","_getFileType","_getExportsFor","_getImportsFor","_getReplacementsFor","_getOutputFor","exportsMap","exportedElement","exportPath","exportName","fileName","fileMap","hasOwnProperty","fileData","_convertFile","_copyFile","Object","freeze"],"mappings":"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"}